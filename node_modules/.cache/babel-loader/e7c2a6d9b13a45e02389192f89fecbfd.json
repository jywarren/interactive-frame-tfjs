{"ast":null,"code":"import _classCallCheck from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { EventDispatcher, MOUSE, Quaternion, Spherical, TOUCH, Vector2, Vector3 } from \"./utils/three.module\"; // This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nvar _changeEvent = {\n  type: \"change\"\n};\nvar _startEvent = {\n  type: \"start\"\n};\nvar _endEvent = {\n  type: \"end\"\n};\n\nvar OrbitControls = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(OrbitControls, _EventDispatcher);\n\n  var _super = _createSuper(OrbitControls);\n\n  function OrbitControls(object, domElement) {\n    var _this;\n\n    _classCallCheck(this, OrbitControls);\n\n    _this = _super.call(this);\n    if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\n    if (domElement === document) console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n    _this.object = object;\n    _this.domElement = domElement;\n    _this.domElement.style.touchAction = \"none\"; // disable touch scroll\n    // Set to false to disable this control\n\n    _this.enabled = true; // \"target\" sets the location of focus, where the object orbits around\n\n    _this.target = new Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )\n\n    _this.minDistance = 0;\n    _this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )\n\n    _this.minZoom = 0;\n    _this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n\n    _this.minPolarAngle = 0; // radians\n\n    _this.maxPolarAngle = Math.PI; // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\n    _this.minAzimuthAngle = -Infinity; // radians\n\n    _this.maxAzimuthAngle = Infinity; // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n\n    _this.enableDamping = false;\n    _this.dampingFactor = 0.05; // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n\n    _this.enableZoom = true;\n    _this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n    _this.enableRotate = true;\n    _this.rotateSpeed = 1.0; // Set to false to disable panning\n\n    _this.enablePan = true;\n    _this.panSpeed = 1.0;\n    _this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\n    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n    _this.autoRotate = false;\n    _this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n    // The four arrow keys\n\n    _this.keys = {\n      LEFT: \"ArrowLeft\",\n      UP: \"ArrowUp\",\n      RIGHT: \"ArrowRight\",\n      BOTTOM: \"ArrowDown\"\n    }; // Mouse buttons\n\n    _this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    }; // Touch fingers\n\n    _this.touches = {\n      ONE: TOUCH.ROTATE,\n      TWO: TOUCH.DOLLY_PAN\n    }; // for reset\n\n    _this.target0 = _this.target.clone();\n    _this.position0 = _this.object.position.clone();\n    _this.zoom0 = _this.object.zoom; // the target DOM element for key events\n\n    _this._domElementKeyEvents = null; //\n    // public methods\n    //\n\n    _this.getPolarAngle = function () {\n      return spherical.phi;\n    };\n\n    _this.getAzimuthalAngle = function () {\n      return spherical.theta;\n    };\n\n    _this.listenToKeyEvents = function (domElement) {\n      domElement.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement;\n    };\n\n    _this.saveState = function () {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n\n    _this.reset = function () {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(_changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    }; // this method is exposed, but perhaps it would be better if we can make it private...\n\n\n    _this.update = function () {\n      var offset = new Vector3(); // so camera.up is the orbit axis\n\n      var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n      var quatInverse = quat.clone().invert();\n      var lastPosition = new Vector3();\n      var lastQuaternion = new Quaternion();\n      var twoPI = 2 * Math.PI;\n      return function update() {\n        var position = scope.object.position;\n        offset.copy(position).sub(scope.target); // rotate offset to \"y-axis-is-up\" space\n\n        offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n        spherical.setFromVector3(offset);\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        } // restrict theta to be between desired limits\n\n\n        var min = scope.minAzimuthAngle;\n        var max = scope.maxAzimuthAngle;\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI;else if (min > Math.PI) min -= twoPI;\n          if (max < -Math.PI) max += twoPI;else if (max > Math.PI) max -= twoPI;\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        } // restrict phi to be between desired limits\n\n\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        spherical.radius *= scale; // restrict radius to be between desired limits\n\n        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n\n        offset.setFromSpherical(spherical); // rotate offset back to \"camera-up-vector-is-up\" space\n\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        scope.object.lookAt(scope.target);\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n\n        scale = 1; // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(_changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n\n        return false;\n      };\n    }();\n\n    _this.dispose = function () {\n      scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.removeEventListener(\"pointercancel\", onPointerCancel);\n      scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n      scope.domElement.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      scope.domElement.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      } //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n    }; //\n    // internals\n    //\n\n\n    var scope = _assertThisInitialized(_this);\n\n    var STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    var state = STATE.NONE;\n    var EPS = 0.000001; // current position in spherical coordinates\n\n    var spherical = new Spherical();\n    var sphericalDelta = new Spherical();\n    var scale = 1;\n    var panOffset = new Vector3();\n    var zoomChanged = false;\n    var rotateStart = new Vector2();\n    var rotateEnd = new Vector2();\n    var rotateDelta = new Vector2();\n    var panStart = new Vector2();\n    var panEnd = new Vector2();\n    var panDelta = new Vector2();\n    var dollyStart = new Vector2();\n    var dollyEnd = new Vector2();\n    var dollyDelta = new Vector2();\n    var pointers = [];\n    var pointerPositions = {};\n\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function rotateLeft(angle) {\n      sphericalDelta.theta -= angle;\n    }\n\n    function rotateUp(angle) {\n      sphericalDelta.phi -= angle;\n    }\n\n    var panLeft = function () {\n      var v = new Vector3();\n      return function panLeft(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    }();\n\n    var panUp = function () {\n      var v = new Vector3();\n      return function panUp(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    }(); // deltaX and deltaY are in pixels; right and down are positive\n\n\n    var pan = function () {\n      var offset = new Vector3();\n      return function pan(deltaX, deltaY) {\n        var element = scope.domElement;\n\n        if (scope.object.isPerspectiveCamera) {\n          // perspective\n          var position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed\n\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n          panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    }();\n\n    function dollyOut(dollyScale) {\n      if (scope.object.isPerspectiveCamera) {\n        scale /= dollyScale;\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n\n    function dollyIn(dollyScale) {\n      if (scope.object.isPerspectiveCamera) {\n        scale *= dollyScale;\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    } //\n    // event callbacks - update the object state\n    //\n\n\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownDolly(event) {\n      dollyStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    } // Adding function to map mouse coordinates to min and max camera rotation\n\n\n    function scaleValue(value, from, to) {\n      var scale = (to[1] - to[0]) / (from[1] - from[0]);\n      var capped = Math.min(from[1], Math.max(from[0], value)) - from[0];\n      return ~~(capped * scale + to[0]);\n    } // function handleMouseMoveRotate(event) {\n\n\n    _this.handleMouseMoveRotate = function (event) {\n      var scaledXCoordinate = scaleValue(event.clientX, [0, window.innerWidth], [-80, 80]);\n      var scaledYCoordinate = scaleValue(event.clientY, [0, window.innerHeight], [-85, 85]);\n      rotateEnd.set(scaledXCoordinate, scaledYCoordinate); // rotateEnd.set(event.clientX / 30, event.clientY / 30);\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      var element = scope.domElement;\n      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    };\n\n    _this.handleFaceMoveRotate = function (faceX, leftEyeYPosition) {\n      var touchscreen = \"ontouchstart\" in window ? true : false;\n      var scaledXCoordinate, scaledYCoordinate;\n\n      if (touchscreen) {\n        scaledXCoordinate = scaleValue(faceX, [0, window.innerWidth], [-150, 100]);\n      } else {\n        scaledXCoordinate = scaleValue(faceX, [0, window.innerWidth], [-85, 85]);\n      }\n\n      if (touchscreen) {\n        scaledYCoordinate = scaleValue(leftEyeYPosition, [0, 480], [-100, 85]);\n      } else {\n        scaledYCoordinate = scaleValue(leftEyeYPosition, [0, 480], [-85, 85]);\n      }\n\n      rotateEnd.set(-scaledXCoordinate, -scaledYCoordinate); // rotateEnd.set(-scaledXCoordinate, 0);\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      var element = scope.domElement;\n      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    };\n\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n\n    function handleMouseUp() {// no-op\n    }\n\n    function handleMouseWheel(event) {\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n\n      scope.update();\n    }\n\n    function handleKeyDown(event) {\n      var needsUpdate = false;\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault();\n        scope.update();\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length === 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        var x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        var y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length === 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        var x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        var y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartDolly() {\n      var dx = pointers[0].pageX - pointers[1].pageX;\n      var dy = pointers[0].pageY - pointers[1].pageY;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly();\n      if (scope.enablePan) handleTouchStartPan();\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly();\n      if (scope.enableRotate) handleTouchStartRotate();\n    }\n\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        var position = getSecondPointerPosition(event);\n        var x = 0.5 * (event.pageX + position.x);\n        var y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      var element = scope.domElement;\n      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      rotateStart.copy(rotateEnd);\n    }\n\n    function handleTouchMovePan(event) {\n      if (pointers.length === 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        var position = getSecondPointerPosition(event);\n        var x = 0.5 * (event.pageX + position.x);\n        var y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n\n    function handleTouchMoveDolly(event) {\n      var position = getSecondPointerPosition(event);\n      var dx = event.pageX - position.x;\n      var dy = event.pageY - position.y;\n      var distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n      if (scope.enablePan) handleTouchMovePan(event);\n    }\n\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n      if (scope.enableRotate) handleTouchMoveRotate(event);\n    }\n\n    function handleTouchEnd() {// no-op\n    } //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n\n    function onPointerDown(event) {\n      if (scope.enabled === false) return;\n\n      if (pointers.length === 0) {\n        scope.domElement.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        scope.domElement.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      } //\n\n\n      addPointer(event);\n\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n\n    function onPointerMove(event) {\n      if (scope.enabled === false) return;\n\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n\n    function onPointerUp(event) {\n      if (scope.enabled === false) return;\n\n      if (event.pointerType === \"touch\") {\n        onTouchEnd();\n      } else {\n        onMouseUp(event);\n      }\n\n      removePointer(event); //\n\n      if (pointers.length === 0) {\n        scope.domElement.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        scope.domElement.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n    }\n\n    function onPointerCancel(event) {\n      removePointer(event);\n    }\n\n    function onMouseDown(event) {\n      var mouseAction;\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n\n        default:\n          mouseAction = -1;\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false) return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n\n          break;\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false) return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return;\n          handleMouseMoveRotate(event);\n          break;\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return;\n          handleMouseMoveDolly(event);\n          break;\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n\n    function onMouseUp(event) {\n      handleMouseUp(event);\n      scope.dispatchEvent(_endEvent);\n      state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n      event.preventDefault();\n      scope.dispatchEvent(_startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false) return;\n      handleKeyDown(event);\n    }\n\n    function onTouchStart(event) {\n      trackPointer(event);\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onTouchMove(event) {\n      trackPointer(event);\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function onTouchEnd(event) {\n      handleTouchEnd(event);\n      scope.dispatchEvent(_endEvent);\n      state = STATE.NONE;\n    }\n\n    function onContextMenu(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n    }\n\n    function addPointer(event) {\n      pointers.push(event);\n    }\n\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n\n      for (var i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n\n    function trackPointer(event) {\n      var position = pointerPositions[event.pointerId];\n\n      if (position === undefined) {\n        position = new Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n\n      position.set(event.pageX, event.pageY);\n    }\n\n    function getSecondPointerPosition(event) {\n      var pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    } //\n\n\n    scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n    scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n    scope.domElement.addEventListener(\"pointercancel\", onPointerCancel);\n    scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n      passive: false\n    }); // force an update at start\n\n    _this.update();\n\n    return _this;\n  }\n\n  return OrbitControls;\n}(EventDispatcher); // This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\n\nvar MapControls = /*#__PURE__*/function (_OrbitControls) {\n  _inherits(MapControls, _OrbitControls);\n\n  var _super2 = _createSuper(MapControls);\n\n  function MapControls(object, domElement) {\n    var _this2;\n\n    _classCallCheck(this, MapControls);\n\n    _this2 = _super2.call(this, object, domElement);\n    _this2.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n    _this2.mouseButtons.LEFT = MOUSE.PAN;\n    _this2.mouseButtons.RIGHT = MOUSE.ROTATE;\n    _this2.touches.ONE = TOUCH.PAN;\n    _this2.touches.TWO = TOUCH.DOLLY_ROTATE;\n    return _this2;\n  }\n\n  return MapControls;\n}(OrbitControls);\n\nexport { OrbitControls, MapControls };","map":{"version":3,"sources":["/Users/warren/sites/interactive-frame-tfjs/src/OrbitControls.js"],"names":["EventDispatcher","MOUSE","Quaternion","Spherical","TOUCH","Vector2","Vector3","_changeEvent","type","_startEvent","_endEvent","OrbitControls","object","domElement","undefined","console","warn","document","error","style","touchAction","enabled","target","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","Math","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","listenToKeyEvents","addEventListener","onKeyDown","saveState","scope","copy","reset","updateProjectionMatrix","dispatchEvent","update","state","STATE","NONE","offset","quat","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","rotateLeft","getAutoRotationAngle","sphericalDelta","min","max","isFinite","makeSafe","radius","scale","addScaledVector","panOffset","add","setFromSpherical","lookAt","multiplyScalar","set","zoomChanged","distanceToSquared","EPS","dot","quaternion","dispose","removeEventListener","onContextMenu","onPointerDown","onPointerCancel","onMouseWheel","ownerDocument","onPointerMove","onPointerUp","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","rotateStart","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","angle","rotateUp","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","isPerspectiveCamera","targetDistance","length","tan","fov","clientHeight","matrix","isOrthographicCamera","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","event","clientX","clientY","handleMouseDownDolly","handleMouseDownPan","scaleValue","value","from","to","capped","handleMouseMoveRotate","scaledXCoordinate","window","innerWidth","scaledYCoordinate","innerHeight","subVectors","x","y","handleFaceMoveRotate","faceX","leftEyeYPosition","touchscreen","handleMouseMoveDolly","handleMouseMovePan","handleMouseUp","handleMouseWheel","handleKeyDown","needsUpdate","code","preventDefault","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchStartDollyPan","handleTouchStartDollyRotate","handleTouchMoveRotate","getSecondPointerPosition","handleTouchMovePan","handleTouchMoveDolly","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","handleTouchEnd","addPointer","pointerType","onTouchStart","onMouseDown","onTouchMove","onMouseMove","onTouchEnd","onMouseUp","removePointer","mouseAction","button","ctrlKey","metaKey","shiftKey","trackPointer","DOLLY_ROTATE","push","pointerId","i","splice","pointer","passive","MapControls"],"mappings":"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","sourcesContent":["import {\n  EventDispatcher,\n  MOUSE,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n} from \"./utils/three.module\";\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: \"change\" };\nconst _startEvent = { type: \"start\" };\nconst _endEvent = { type: \"end\" };\n\nclass OrbitControls extends EventDispatcher {\n  constructor(object, domElement) {\n    super();\n\n    if (domElement === undefined)\n      console.warn(\n        'THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.'\n      );\n    if (domElement === document)\n      console.error(\n        'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.'\n      );\n\n    this.object = object;\n    this.domElement = domElement;\n    this.domElement.style.touchAction = \"none\"; // disable touch scroll\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    this.target = new Vector3();\n\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // How far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = false;\n    this.dampingFactor = 0.05;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n    this.panSpeed = 1.0;\n    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n    // The four arrow keys\n    this.keys = {\n      LEFT: \"ArrowLeft\",\n      UP: \"ArrowUp\",\n      RIGHT: \"ArrowRight\",\n      BOTTOM: \"ArrowDown\",\n    };\n\n    // Mouse buttons\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN,\n    };\n\n    // Touch fingers\n    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n\n    // the target DOM element for key events\n    this._domElementKeyEvents = null;\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = function () {\n      return spherical.phi;\n    };\n\n    this.getAzimuthalAngle = function () {\n      return spherical.theta;\n    };\n\n    this.listenToKeyEvents = function (domElement) {\n      domElement.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement;\n    };\n\n    this.saveState = function () {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n\n    this.reset = function () {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(_changeEvent);\n\n      scope.update();\n\n      state = STATE.NONE;\n    };\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = (function () {\n      const offset = new Vector3();\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(\n        object.up,\n        new Vector3(0, 1, 0)\n      );\n      const quatInverse = quat.clone().invert();\n\n      const lastPosition = new Vector3();\n      const lastQuaternion = new Quaternion();\n\n      const twoPI = 2 * Math.PI;\n\n      return function update() {\n        const position = scope.object.position;\n\n        offset.copy(position).sub(scope.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset);\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI;\n          else if (min > Math.PI) min -= twoPI;\n\n          if (max < -Math.PI) max += twoPI;\n          else if (max > Math.PI) max -= twoPI;\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2\n                ? Math.max(min, spherical.theta)\n                : Math.min(max, spherical.theta);\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(\n          scope.minPolarAngle,\n          Math.min(scope.maxPolarAngle, spherical.phi)\n        );\n\n        spherical.makeSafe();\n\n        spherical.radius *= scale;\n\n        // restrict radius to be between desired limits\n        spherical.radius = Math.max(\n          scope.minDistance,\n          Math.min(scope.maxDistance, spherical.radius)\n        );\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n\n        offset.setFromSpherical(spherical);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(scope.target).add(offset);\n\n        scope.object.lookAt(scope.target);\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n\n          panOffset.set(0, 0, 0);\n        }\n\n        scale = 1;\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          scope.dispatchEvent(_changeEvent);\n\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n\n          return true;\n        }\n\n        return false;\n      };\n    })();\n\n    this.dispose = function () {\n      scope.domElement.removeEventListener(\"contextmenu\", onContextMenu);\n\n      scope.domElement.removeEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.removeEventListener(\"pointercancel\", onPointerCancel);\n      scope.domElement.removeEventListener(\"wheel\", onMouseWheel);\n\n      scope.domElement.ownerDocument.removeEventListener(\n        \"pointermove\",\n        onPointerMove\n      );\n      scope.domElement.ownerDocument.removeEventListener(\n        \"pointerup\",\n        onPointerUp\n      );\n\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    };\n\n    //\n    // internals\n    //\n\n    const scope = this;\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    };\n\n    let state = STATE.NONE;\n\n    const EPS = 0.000001;\n\n    // current position in spherical coordinates\n    const spherical = new Spherical();\n    const sphericalDelta = new Spherical();\n\n    let scale = 1;\n    const panOffset = new Vector3();\n    let zoomChanged = false;\n\n    const rotateStart = new Vector2();\n    const rotateEnd = new Vector2();\n    const rotateDelta = new Vector2();\n\n    const panStart = new Vector2();\n    const panEnd = new Vector2();\n    const panDelta = new Vector2();\n\n    const dollyStart = new Vector2();\n    const dollyEnd = new Vector2();\n    const dollyDelta = new Vector2();\n\n    const pointers = [];\n    const pointerPositions = {};\n\n    function getAutoRotationAngle() {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function rotateLeft(angle) {\n      sphericalDelta.theta -= angle;\n    }\n\n    function rotateUp(angle) {\n      sphericalDelta.phi -= angle;\n    }\n\n    const panLeft = (function () {\n      const v = new Vector3();\n\n      return function panLeft(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n        v.multiplyScalar(-distance);\n\n        panOffset.add(v);\n      };\n    })();\n\n    const panUp = (function () {\n      const v = new Vector3();\n\n      return function panUp(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n\n        v.multiplyScalar(distance);\n\n        panOffset.add(v);\n      };\n    })();\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (function () {\n      const offset = new Vector3();\n\n      return function pan(deltaX, deltaY) {\n        const element = scope.domElement;\n\n        if (scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(\n            ((scope.object.fov / 2) * Math.PI) / 180.0\n          );\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft(\n            (2 * deltaX * targetDistance) / element.clientHeight,\n            scope.object.matrix\n          );\n          panUp(\n            (2 * deltaY * targetDistance) / element.clientHeight,\n            scope.object.matrix\n          );\n        } else if (scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) /\n              scope.object.zoom /\n              element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) /\n              scope.object.zoom /\n              element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn(\n            \"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\"\n          );\n          scope.enablePan = false;\n        }\n      };\n    })();\n\n    function dollyOut(dollyScale) {\n      if (scope.object.isPerspectiveCamera) {\n        scale /= dollyScale;\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.zoom = Math.max(\n          scope.minZoom,\n          Math.min(scope.maxZoom, scope.object.zoom * dollyScale)\n        );\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn(\n          \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"\n        );\n        scope.enableZoom = false;\n      }\n    }\n\n    function dollyIn(dollyScale) {\n      if (scope.object.isPerspectiveCamera) {\n        scale *= dollyScale;\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.zoom = Math.max(\n          scope.minZoom,\n          Math.min(scope.maxZoom, scope.object.zoom / dollyScale)\n        );\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn(\n          \"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"\n        );\n        scope.enableZoom = false;\n      }\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownDolly(event) {\n      dollyStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n\n    // Adding function to map mouse coordinates to min and max camera rotation\n    function scaleValue(value, from, to) {\n      var scale = (to[1] - to[0]) / (from[1] - from[0]);\n      var capped = Math.min(from[1], Math.max(from[0], value)) - from[0];\n\n      return ~~(capped * scale + to[0]);\n    }\n\n    // function handleMouseMoveRotate(event) {\n    this.handleMouseMoveRotate = function (event) {\n      let scaledXCoordinate = scaleValue(\n        event.clientX,\n        [0, window.innerWidth],\n        [-80, 80]\n      );\n\n      let scaledYCoordinate = scaleValue(\n        event.clientY,\n        [0, window.innerHeight],\n        [-85, 85]\n      );\n\n      rotateEnd.set(scaledXCoordinate, scaledYCoordinate);\n      // rotateEnd.set(event.clientX / 30, event.clientY / 30);\n\n      rotateDelta\n        .subVectors(rotateEnd, rotateStart)\n        .multiplyScalar(scope.rotateSpeed);\n\n      const element = scope.domElement;\n\n      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n      rotateStart.copy(rotateEnd);\n\n      scope.update();\n    };\n\n    this.handleFaceMoveRotate = function (faceX, leftEyeYPosition) {\n      let touchscreen = \"ontouchstart\" in window ? true : false;\n      let scaledXCoordinate, scaledYCoordinate;\n\n      if (touchscreen) {\n        scaledXCoordinate = scaleValue(\n          faceX,\n          [0, window.innerWidth],\n          [-150, 100]\n        );\n      } else {\n        scaledXCoordinate = scaleValue(\n          faceX,\n          [0, window.innerWidth],\n          [-85, 85]\n        );\n      }\n\n      if (touchscreen) {\n        scaledYCoordinate = scaleValue(leftEyeYPosition, [0, 480], [-100, 85]);\n      } else {\n        scaledYCoordinate = scaleValue(leftEyeYPosition, [0, 480], [-85, 85]);\n      }\n\n      rotateEnd.set(-scaledXCoordinate, -scaledYCoordinate);\n      // rotateEnd.set(-scaledXCoordinate, 0);\n\n      rotateDelta\n        .subVectors(rotateEnd, rotateStart)\n        .multiplyScalar(scope.rotateSpeed);\n\n      const element = scope.domElement;\n\n      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n      rotateStart.copy(rotateEnd);\n\n      scope.update();\n    };\n\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n\n      dollyStart.copy(dollyEnd);\n\n      scope.update();\n    }\n\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n      pan(panDelta.x, panDelta.y);\n\n      panStart.copy(panEnd);\n\n      scope.update();\n    }\n\n    function handleMouseUp(/*event*/) {\n      // no-op\n    }\n\n    function handleMouseWheel(event) {\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n\n      scope.update();\n    }\n\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault();\n\n        scope.update();\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length === 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n\n        rotateStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length === 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n\n        panStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      dollyStart.set(0, distance);\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly();\n\n      if (scope.enablePan) handleTouchStartPan();\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly();\n\n      if (scope.enableRotate) handleTouchStartRotate();\n    }\n\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n\n        rotateEnd.set(x, y);\n      }\n\n      rotateDelta\n        .subVectors(rotateEnd, rotateStart)\n        .multiplyScalar(scope.rotateSpeed);\n\n      const element = scope.domElement;\n\n      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n      rotateStart.copy(rotateEnd);\n    }\n\n    function handleTouchMovePan(event) {\n      if (pointers.length === 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n\n        panEnd.set(x, y);\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n      pan(panDelta.x, panDelta.y);\n\n      panStart.copy(panEnd);\n    }\n\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      dollyEnd.set(0, distance);\n\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n      dollyOut(dollyDelta.y);\n\n      dollyStart.copy(dollyEnd);\n    }\n\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n\n      if (scope.enablePan) handleTouchMovePan(event);\n    }\n\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n\n      if (scope.enableRotate) handleTouchMoveRotate(event);\n    }\n\n    function handleTouchEnd(/*event*/) {\n      // no-op\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event) {\n      if (scope.enabled === false) return;\n\n      if (pointers.length === 0) {\n        scope.domElement.ownerDocument.addEventListener(\n          \"pointermove\",\n          onPointerMove\n        );\n        scope.domElement.ownerDocument.addEventListener(\n          \"pointerup\",\n          onPointerUp\n        );\n      }\n\n      //\n\n      addPointer(event);\n\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n\n    function onPointerMove(event) {\n      if (scope.enabled === false) return;\n\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n\n    function onPointerUp(event) {\n      if (scope.enabled === false) return;\n\n      if (event.pointerType === \"touch\") {\n        onTouchEnd();\n      } else {\n        onMouseUp(event);\n      }\n\n      removePointer(event);\n\n      //\n\n      if (pointers.length === 0) {\n        scope.domElement.ownerDocument.removeEventListener(\n          \"pointermove\",\n          onPointerMove\n        );\n        scope.domElement.ownerDocument.removeEventListener(\n          \"pointerup\",\n          onPointerUp\n        );\n      }\n    }\n\n    function onPointerCancel(event) {\n      removePointer(event);\n    }\n\n    function onMouseDown(event) {\n      let mouseAction;\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n\n        default:\n          mouseAction = -1;\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return;\n\n          handleMouseDownDolly(event);\n\n          state = STATE.DOLLY;\n\n          break;\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return;\n\n            handleMouseDownPan(event);\n\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false) return;\n\n            handleMouseDownRotate(event);\n\n            state = STATE.ROTATE;\n          }\n\n          break;\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return;\n\n            handleMouseDownRotate(event);\n\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false) return;\n\n            handleMouseDownPan(event);\n\n            state = STATE.PAN;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return;\n\n          handleMouseMoveRotate(event);\n\n          break;\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return;\n\n          handleMouseMoveDolly(event);\n\n          break;\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return;\n\n          handleMouseMovePan(event);\n\n          break;\n      }\n    }\n\n    function onMouseUp(event) {\n      handleMouseUp(event);\n\n      scope.dispatchEvent(_endEvent);\n\n      state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n      if (\n        scope.enabled === false ||\n        scope.enableZoom === false ||\n        (state !== STATE.NONE && state !== STATE.ROTATE)\n      )\n        return;\n\n      event.preventDefault();\n\n      scope.dispatchEvent(_startEvent);\n\n      handleMouseWheel(event);\n\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false) return;\n\n      handleKeyDown(event);\n    }\n\n    function onTouchStart(event) {\n      trackPointer(event);\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return;\n\n              handleTouchStartRotate();\n\n              state = STATE.TOUCH_ROTATE;\n\n              break;\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return;\n\n              handleTouchStartPan();\n\n              state = STATE.TOUCH_PAN;\n\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n\n              handleTouchStartDollyPan();\n\n              state = STATE.TOUCH_DOLLY_PAN;\n\n              break;\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n\n              handleTouchStartDollyRotate();\n\n              state = STATE.TOUCH_DOLLY_ROTATE;\n\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onTouchMove(event) {\n      trackPointer(event);\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return;\n\n          handleTouchMoveRotate(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return;\n\n          handleTouchMovePan(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return;\n\n          handleTouchMoveDollyPan(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n\n          handleTouchMoveDollyRotate(event);\n\n          scope.update();\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function onTouchEnd(event) {\n      handleTouchEnd(event);\n\n      scope.dispatchEvent(_endEvent);\n\n      state = STATE.NONE;\n    }\n\n    function onContextMenu(event) {\n      if (scope.enabled === false) return;\n\n      event.preventDefault();\n    }\n\n    function addPointer(event) {\n      pointers.push(event);\n    }\n\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n\n      if (position === undefined) {\n        position = new Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n\n      position.set(event.pageX, event.pageY);\n    }\n\n    function getSecondPointerPosition(event) {\n      const pointer =\n        event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n\n      return pointerPositions[pointer.pointerId];\n    }\n\n    //\n\n    scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n\n    scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n    scope.domElement.addEventListener(\"pointercancel\", onPointerCancel);\n    scope.domElement.addEventListener(\"wheel\", onMouseWheel, {\n      passive: false,\n    });\n\n    // force an update at start\n\n    this.update();\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n\n    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN;\n    this.mouseButtons.RIGHT = MOUSE.ROTATE;\n\n    this.touches.ONE = TOUCH.PAN;\n    this.touches.TWO = TOUCH.DOLLY_ROTATE;\n  }\n}\n\nexport { OrbitControls, MapControls };\n"]},"metadata":{},"sourceType":"module"}