{"ast":null,"code":"import _classCallCheck from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/warren/sites/interactive-frame-tfjs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { MathUtils, Quaternion, Vector3 } from \"./three.module\";\n\nvar _va = /*@__PURE__*/new Vector3(),\n    // from pe to pa\n_vb = /*@__PURE__*/new Vector3(),\n    // from pe to pb\n_vc = /*@__PURE__*/new Vector3(),\n    // from pe to pc\n_vr = /*@__PURE__*/new Vector3(),\n    // right axis of screen\n_vu = /*@__PURE__*/new Vector3(),\n    // up axis of screen\n_vn = /*@__PURE__*/new Vector3(),\n    // normal vector of screen\n_vec = /*@__PURE__*/new Vector3(),\n    // temporary vector\n_quat = /*@__PURE__*/new Quaternion(); // temporary quaternion\n\n\nvar CameraUtils = /*#__PURE__*/function () {\n  function CameraUtils() {\n    _classCallCheck(this, CameraUtils);\n  }\n\n  _createClass(CameraUtils, null, [{\n    key: \"frameCorners\",\n    value:\n    /** Set a PerspectiveCamera's projectionMatrix and quaternion\n     * to exactly frame the corners of an arbitrary rectangle.\n     * NOTE: This function ignores the standard parameters;\n     * do not call updateProjectionMatrix() after this!\n     * @param {Vector3} bottomLeftCorner\n     * @param {Vector3} bottomRightCorner\n     * @param {Vector3} topLeftCorner\n     * @param {boolean} estimateViewFrustum */\n    function frameCorners(camera, bottomLeftCorner, bottomRightCorner, topLeftCorner) {\n      var estimateViewFrustum = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var pa = bottomLeftCorner,\n          pb = bottomRightCorner,\n          pc = topLeftCorner;\n      var pe = camera.position; // eye position\n\n      var n = camera.near; // distance of near clipping plane\n\n      var f = camera.far; //distance of far clipping plane\n\n      _vr.copy(pb).sub(pa).normalize();\n\n      _vu.copy(pc).sub(pa).normalize();\n\n      _vn.crossVectors(_vr, _vu).normalize();\n\n      _va.copy(pa).sub(pe); // from pe to pa\n\n\n      _vb.copy(pb).sub(pe); // from pe to pb\n\n\n      _vc.copy(pc).sub(pe); // from pe to pc\n\n\n      var d = -_va.dot(_vn); // distance from eye to screen\n\n      var l = _vr.dot(_va) * n / d; // distance to left screen edge\n\n      var r = _vr.dot(_vb) * n / d; // distance to right screen edge\n\n      var b = _vu.dot(_va) * n / d; // distance to bottom screen edge\n\n      var t = _vu.dot(_vc) * n / d; // distance to top screen edge\n      // Set the camera rotation to match the focal plane to the corners' plane\n\n      _quat.setFromUnitVectors(_vec.set(0, 1, 0), _vu);\n\n      camera.quaternion.setFromUnitVectors(_vec.set(0, 0, 1).applyQuaternion(_quat), _vn).multiply(_quat); // Set the off-axis projection matrix to match the corners\n\n      camera.projectionMatrix.set(2.0 * n / (r - l), 0.0, (r + l) / (r - l), 0.0, 0.0, 2.0 * n / (t - b), (t + b) / (t - b), 0.0, 0.0, 0.0, (f + n) / (n - f), 2.0 * f * n / (n - f), 0.0, 0.0, -1.0, 0.0);\n      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert(); // FoV estimation to fix frustum culling\n\n      if (estimateViewFrustum) {\n        // Set fieldOfView to a conservative estimate\n        // to make frustum tall/wide enough to encompass it\n        camera.fov = MathUtils.RAD2DEG / Math.min(1.0, camera.aspect) * Math.atan((_vec.copy(pb).sub(pa).length() + _vec.copy(pc).sub(pa).length()) / _va.length());\n      }\n    }\n  }]);\n\n  return CameraUtils;\n}();\n\nexport { CameraUtils };","map":{"version":3,"sources":["/Users/warren/sites/interactive-frame-tfjs/src/utils/CameraUtils.js"],"names":["MathUtils","Quaternion","Vector3","_va","_vb","_vc","_vr","_vu","_vn","_vec","_quat","CameraUtils","camera","bottomLeftCorner","bottomRightCorner","topLeftCorner","estimateViewFrustum","pa","pb","pc","pe","position","n","near","f","far","copy","sub","normalize","crossVectors","d","dot","l","r","b","t","setFromUnitVectors","set","quaternion","applyQuaternion","multiply","projectionMatrix","projectionMatrixInverse","invert","fov","RAD2DEG","Math","min","aspect","atan","length"],"mappings":"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","sourcesContent":["import { MathUtils, Quaternion, Vector3 } from \"./three.module\";\n\nconst _va = /*@__PURE__*/ new Vector3(), // from pe to pa\n  _vb = /*@__PURE__*/ new Vector3(), // from pe to pb\n  _vc = /*@__PURE__*/ new Vector3(), // from pe to pc\n  _vr = /*@__PURE__*/ new Vector3(), // right axis of screen\n  _vu = /*@__PURE__*/ new Vector3(), // up axis of screen\n  _vn = /*@__PURE__*/ new Vector3(), // normal vector of screen\n  _vec = /*@__PURE__*/ new Vector3(), // temporary vector\n  _quat = /*@__PURE__*/ new Quaternion(); // temporary quaternion\n\nclass CameraUtils {\n  /** Set a PerspectiveCamera's projectionMatrix and quaternion\n   * to exactly frame the corners of an arbitrary rectangle.\n   * NOTE: This function ignores the standard parameters;\n   * do not call updateProjectionMatrix() after this!\n   * @param {Vector3} bottomLeftCorner\n   * @param {Vector3} bottomRightCorner\n   * @param {Vector3} topLeftCorner\n   * @param {boolean} estimateViewFrustum */\n  static frameCorners(\n    camera,\n    bottomLeftCorner,\n    bottomRightCorner,\n    topLeftCorner,\n    estimateViewFrustum = false\n  ) {\n    const pa = bottomLeftCorner,\n      pb = bottomRightCorner,\n      pc = topLeftCorner;\n    const pe = camera.position; // eye position\n    const n = camera.near; // distance of near clipping plane\n    const f = camera.far; //distance of far clipping plane\n\n    _vr.copy(pb).sub(pa).normalize();\n    _vu.copy(pc).sub(pa).normalize();\n    _vn.crossVectors(_vr, _vu).normalize();\n\n    _va.copy(pa).sub(pe); // from pe to pa\n    _vb.copy(pb).sub(pe); // from pe to pb\n    _vc.copy(pc).sub(pe); // from pe to pc\n\n    const d = -_va.dot(_vn); // distance from eye to screen\n    const l = (_vr.dot(_va) * n) / d; // distance to left screen edge\n    const r = (_vr.dot(_vb) * n) / d; // distance to right screen edge\n    const b = (_vu.dot(_va) * n) / d; // distance to bottom screen edge\n    const t = (_vu.dot(_vc) * n) / d; // distance to top screen edge\n\n    // Set the camera rotation to match the focal plane to the corners' plane\n    _quat.setFromUnitVectors(_vec.set(0, 1, 0), _vu);\n    camera.quaternion\n      .setFromUnitVectors(_vec.set(0, 0, 1).applyQuaternion(_quat), _vn)\n      .multiply(_quat);\n\n    // Set the off-axis projection matrix to match the corners\n    camera.projectionMatrix.set(\n      (2.0 * n) / (r - l),\n      0.0,\n      (r + l) / (r - l),\n      0.0,\n      0.0,\n      (2.0 * n) / (t - b),\n      (t + b) / (t - b),\n      0.0,\n      0.0,\n      0.0,\n      (f + n) / (n - f),\n      (2.0 * f * n) / (n - f),\n      0.0,\n      0.0,\n      -1.0,\n      0.0\n    );\n    camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();\n\n    // FoV estimation to fix frustum culling\n    if (estimateViewFrustum) {\n      // Set fieldOfView to a conservative estimate\n      // to make frustum tall/wide enough to encompass it\n      camera.fov =\n        (MathUtils.RAD2DEG / Math.min(1.0, camera.aspect)) *\n        Math.atan(\n          (_vec.copy(pb).sub(pa).length() + _vec.copy(pc).sub(pa).length()) /\n            _va.length()\n        );\n    }\n  }\n}\n\nexport { CameraUtils };\n"]},"metadata":{},"sourceType":"module"}